From 5e4c131b22cc47282e2b1a6a05718e9f988597ce Mon Sep 17 00:00:00 2001
From: CharlesJ9752 <1499695378@qq.com>
Date: Tue, 8 Nov 2022 13:34:20 +0800
Subject: [PATCH] exp15

---
 .../mycpu_env/myCPU/EXE.v                     |   5 +-
 .../mycpu_env/myCPU/ID.v                      |  85 ++--
 .../mycpu_env/myCPU/IF.v                      | 150 +++---
 .../mycpu_env/myCPU/MEM.v                     |  30 +-
 .../mycpu_env/myCPU/WB.v                      |   5 +-
 .../mycpu_env/myCPU/bridge.v                  | 454 ++++++++++++++++++
 .../mycpu_env/myCPU/csr.v                     |  90 ++--
 .../mycpu_env/myCPU/mycpu.h                   |   2 +-
 .../mycpu_env/myCPU/mycpu_top.v               | 215 +++++++--
 9 files changed, 858 insertions(+), 178 deletions(-)
 create mode 100644 exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/bridge.v

diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/EXE.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/EXE.v
index a28a0fd..5a56b7c 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/EXE.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/EXE.v
@@ -86,7 +86,10 @@ module EXE (
     end
 //主bus连接
     always @(posedge clk ) begin
-        if (id_exe_valid & exe_allowin) begin
+        if(~resetn)begin
+            id_exe_bus_vld <= `ID_EXE_BUS_WDTH'b0;
+        end
+        else if (id_exe_valid & exe_allowin) begin
             id_exe_bus_vld <= id_exe_bus; 
         end
     end
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/ID.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/ID.v
index 3ae113b..243470b 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/ID.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/ID.v
@@ -1,44 +1,44 @@
 `include "mycpu.h"
-//译码，生成操作数
+//���룬���ɲ�����
 module ID (
     input                                   clk,
     input                                   resetn,
-    //与IF阶段
+    //��IF�׶�
     input                                   if_id_valid,
     output                                  id_allowin,
     input   [`IF_ID_BUS_WDTH - 1:0]         if_id_bus,//exc_type + pc + inst
     output  [`ID_IF_BUS_WDTH - 1:0]         id_if_bus,//en_brch+br_target
-    //与EXE阶段
+    //��EXE�׶�
     input                                   exe_allowin,
     output                                  id_exe_valid,
     output  [`ID_EXE_BUS_WDTH - 1:0]        id_exe_bus,//add 2bits
-    //来自WB阶段
+    //����WB�׶�
     input   [`WB_ID_BUS_WDTH - 1:0]         wb_id_bus,
-    //阻塞和前递信号
+    //������ǰ���ź�
     input   [`EXE_WR_BUS_WDTH - 1:0]        exe_wr_bus,
     input   [`MEM_WR_BUS_WDTH - 1:0]        mem_wr_bus,
-    //异常&中断
+    //�쳣&�ж�
     input                                   wb_exc,
     input                                   csr_has_int,
-    //与csr寄存器
+    //��csr�Ĵ���
     input   [31:0]                          csr_rdata,
     output  [13:0]                          csr_raddr,
     input   [`EXE_CSR_BLK_BUS_WDTH - 1:0]   exe_csr_blk_bus,
     input   [`MEM_CSR_BLK_BUS_WDTH - 1:0]   mem_csr_blk_bus,
     input   [`WB_CSR_BLK_BUS_WDTH - 1:0]    wb_csr_blk_bus//ertn_flush in this
 );
-//信号定义
-    //控制信号
+//�źŶ���
+    //�����ź�
     reg                                     id_valid;
     wire                                    id_ready_go;
     wire                                    id_en_brch;
-    //指令和pc
+    //ָ���pc
     wire    [31:0]                          id_br_target;
     wire    [31:0]                          id_inst;
     wire    [31:0]                          id_pc;
     //bus
     reg     [`IF_ID_BUS_WDTH - 1:0]         if_id_bus_vld;
-    //阻塞和前递
+    //������ǰ��
     wire                                    exe_en_bypass;
     wire                                    exe_en_block;
     wire                                    exe_res_from_mem;
@@ -50,7 +50,7 @@ module ID (
     wire    [ 4:0]                          mem_dest;
     wire    [ 4:0]                          wb_dest;
     wire                                    en_brch_cancel;
-    //异常和中断
+    //�쳣���ж�
     wire [`NUM_TYPES - 1:0]                 id_exc_type;
     //csr
     wire                                    id_csr_we;
@@ -74,25 +74,48 @@ module ID (
             
 
 
-//控制信号的赋值
+//�����źŵĸ�ֵ
     assign id_ready_go = ~csr_blk & ~( exe_en_block & ((exe_dest==rf_raddr1) & addr1_valid //untest
-                                    |(exe_dest==rf_raddr2) & addr2_valid));//in case of load
-    assign id_exe_valid = id_ready_go && id_valid;
+                                    |(exe_dest==rf_raddr2) & addr2_valid)) 
+                                    & ~( mem_en_block & ((mem_dest==rf_raddr1) & addr1_valid //untest
+                                    |(mem_dest==rf_raddr2) & addr2_valid));//in case of load
+    reg exc_reg;
+    reg ertn_reg;
+    always @(posedge clk) begin
+        if (~resetn) begin
+            exc_reg <= 1'b0;
+            ertn_reg <= 1'b0;
+        end 
+        else if (wb_exc) begin
+            exc_reg <= 1'b1;
+        end 
+        else if (ertn_flush) begin
+            ertn_reg <= 1'b1;
+        end 
+        else if (if_id_valid & id_allowin)begin
+            exc_reg <= 1'b0;
+            ertn_reg <= 1'b0;
+        end 
+    end
+
+
+    assign is_ertn_exc = (wb_exc | ertn_flush | exc_reg | ertn_reg);
+    assign id_exe_valid = id_ready_go && id_valid &  ~is_ertn_exc;
     assign id_allowin = id_ready_go && exe_allowin || ~id_valid;
     always @(posedge clk ) begin
         if(~resetn) begin
             id_valid <= 1'b0;
         end
-        else if(br_taken) begin
-            id_valid <= 1'b0;
-        end
         else if(id_allowin) begin
             id_valid <= if_id_valid;
         end
     end
-//主bus连接
+//��bus����
     always @(posedge clk ) begin
-        if(if_id_valid & id_allowin)begin
+        if(~resetn)begin
+            if_id_bus_vld <= `IF_ID_BUS_WDTH'b0;
+        end
+        else if(if_id_valid & id_allowin)begin
             if_id_bus_vld <= if_id_bus;
         end
     end
@@ -108,7 +131,7 @@ module ID (
         id_alu_op, id_alu_src1, id_alu_src2,
         id_dest, id_rkd_value, id_inst, id_pc
     };
-//译码，生成操作数
+//���룬���ɲ�����
     wire [ 5:0] op_31_26;
     wire [ 3:0] op_25_22;
     wire [ 1:0] op_21_20;
@@ -170,7 +193,7 @@ module ID (
     wire        inst_st_h;    
 
     /************************/
-    //异常&中断
+    //�쳣&�ж�
     wire        inst_syscall;
     wire        inst_csrrd;
     wire        inst_csrwr;
@@ -289,7 +312,7 @@ module ID (
     assign inst_st_h   = op_31_26_d[6'h0a] & op_25_22_d[4'h5];
 
     /************************/
-    //异常&中断
+    //�쳣&�ж�
     assign inst_syscall= op_31_26_d[6'b000000] & op_25_22_d[4'b0000] & op_21_20_d[2'b10] & op_19_15_d[5'b10110];
     assign inst_csrrd  = (id_inst[31:24]==8'b00000100) & (rj==5'b00000);
     assign inst_csrwr  = (id_inst[31:24]==8'b00000100) & (rj==5'b00001);
@@ -382,7 +405,7 @@ module ID (
     assign rf_raddr1 = rj;
     assign rf_raddr2 = src_reg_is_rd ? rd :rk;
     assign rj_eq_rd = (rj_value == id_rkd_value);
-    assign rj_less_rd =($signed(rj_value) < $signed(id_rkd_value));   //需要加上signed                                      //change 6
+    assign rj_less_rd =($signed(rj_value) < $signed(id_rkd_value));   //��Ҫ����signed                                      //change 6
     assign rj_lessu_rd =($unsigned(rj_value) < $unsigned(id_rkd_value));                    //change 7
     assign id_en_brch = (   inst_beq  &&  rj_eq_rd
                     || inst_bne  && !rj_eq_rd
@@ -403,13 +426,13 @@ module ID (
     };
     assign id_alu_src1 = src1_is_pc  ? id_pc : rj_value;
     assign id_alu_src2 = src2_is_imm ? imm : id_rkd_value;
-//处理阻塞和前递（regfile寄存器和csr寄存器）
+//����������ǰ�ݣ�regfile�Ĵ�����csr�Ĵ�����
     //regfile
     assign  {
         exe_en_bypass, exe_en_block, exe_dest, exe_wdata
     } = exe_wr_bus;
     assign  {
-        mem_en_bypass, mem_dest, mem_wdata
+        mem_en_bypass, mem_en_block,mem_dest, mem_wdata
     } = mem_wr_bus;
     assign addr1_valid = ~id_exc_type[`TYPE_INE] & 
                     ~(inst_b | inst_bl | inst_csrrd | inst_csrwr | inst_syscall | inst_ertn | inst_break |
@@ -428,12 +451,12 @@ module ID (
                             (mem_en_bypass & (mem_dest == rf_raddr2) & addr2_valid & |rf_raddr2)? mem_wdata :
                             (rf_we         & (rf_waddr == rf_raddr2) & addr2_valid & |rf_raddr2)? rf_wdata  : rf_rdata2;
 
-    //csr寄存器
+    //csr�Ĵ���
     assign {exe_csr_we, exe_ertn, exe_csr_waddr} = exe_csr_blk_bus;
     assign {mem_csr_we, mem_ertn, mem_csr_waddr} = mem_csr_blk_bus;
     assign {wb_csr_we, ertn_flush, wb_csr_waddr}    = wb_csr_blk_bus;
 
-    assign csr_blk = id_csr_re & (//阻塞信号
+    assign csr_blk = id_csr_re & (//�����ź�
                         exe_csr_we&csr_raddr==exe_csr_waddr&(|exe_csr_waddr)|
                         mem_csr_we&csr_raddr==mem_csr_waddr&(|mem_csr_waddr)|
                         wb_csr_we&csr_raddr==wb_csr_waddr&(|wb_csr_waddr)|
@@ -442,7 +465,7 @@ module ID (
                         (ertn_flush)&(wb_csr_waddr==`CSR_ERA|wb_csr_waddr==`CSR_PRMD|csr_raddr==`CSR_CRMD)//jyh
                     );
 
-//读写regfile寄存器
+//��дregfile�Ĵ���
   assign {
         rf_we, rf_waddr, rf_wdata
     } = wb_id_bus;
@@ -456,7 +479,7 @@ module ID (
         .waddr  (rf_waddr ),
         .wdata  (rf_wdata )
     );
-//读写csr寄存器
+//��дcsr�Ĵ���
     assign id_csr_we    = inst_csrwr | inst_csrxchg;
     assign id_csr_re    = inst_csrrd | inst_csrwr | inst_csrxchg | inst_rdcntid_w;
     assign id_csr_waddr = id_inst[23:10];
@@ -481,7 +504,7 @@ module ID (
                             {32{id_csr_waddr == `CSR_TICLR }} & `CSR_MASK_TICLR;
 
 
-//中断和异常标志
+//�жϺ��쳣��־
     /**new added**/
     assign  id_exc_type[`TYPE_SYS]=inst_syscall;
     assign  id_exc_type[`TYPE_ADEF]=if_exc_type[`TYPE_ADEF];
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/IF.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/IF.v
index 4029791..8d5503a 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/IF.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/IF.v
@@ -49,13 +49,14 @@ module IF (
     assign  to_pf_valid = 1'b1;
     assign  pf_allowin  = 1'b1;//untest
     assign  pf_if_valid = pf_ready_go & pf_valid;
-    assign  pf_ready_go = inst_sram_addr_ok & inst_sram_req;
+    assign  pf_ready_go =  inst_sram_addr_ok && inst_sram_req
+                        &&!(wb_exc||ertn_flush||br_stall||((pf_ertn_reg || pf_exc_reg)&&cancel));//untest
     //生成pc
     wire    [31:0]                  pf_seqpc;
     wire    [31:0]                  pf_nextpc;
     reg     [31:0]                  pf_pc;
-    assign  pf_nextpc = wb_exc     ?    exc_entaddr   : exc_reg              ?  entaddr_reg :
-                        ertn_flush ?    exc_retaddr   : ertn_reg             ?  retaddr_reg :
+    assign  pf_nextpc = wb_exc     ?    exc_entaddr   : pf_exc_reg              ?  pf_entaddr_reg :
+                        ertn_flush ?    exc_retaddr   : pf_ertn_reg             ?  pf_retaddr_reg :
                         br_reg ?        br_target_reg : br_taken & ~br_stall ?  br_target   :
                         pf_seqpc;
     assign  pf_seqpc = pf_pc + 3'h4;
@@ -68,69 +69,95 @@ module IF (
         end
     end
     //中断返回、中断陷入和跳转的地址
-    reg                             exc_reg;
-    reg     [31:0]                  entaddr_reg;
-    reg                             ertn_reg;
-    reg     [31:0]                  retaddr_reg;
+    reg                             pf_exc_reg;
+    reg     [31:0]                  pf_entaddr_reg;
+    reg                             pf_ertn_reg;
+    reg     [31:0]                  pf_retaddr_reg;
     reg                             br_reg;
     reg     [31:0]                  br_target_reg;
     //控制信号
-    always @(posedge clk ) begin
-        if(~resetn || pf_ready_go && if_allowin)begin
+    always @(posedge clk) begin
+        if (~resetn) begin
             br_reg <= 1'b0;
         end
-        else if (~br_stall & br_taken) begin
-            br_reg<=1'b1;
-        end
+        else if (br_taken && !br_stall) begin
+            br_reg <= 1'b1;
+        end 
+        else if (inst_sram_addr_ok && ~cancel && if_allowin)begin
+            br_reg <= 1'b0;
+        end 
     end
-    always @(posedge clk ) begin
-        if(~resetn || pf_ready_go && if_allowin)begin
-            exc_reg<=1'b0;
-            ertn_reg<=1'b0;
-        end
-        else if (wb_exc)begin
-            exc_reg<=1'b1;
-        end
-        else if (ertn_flush)begin
-            ertn_reg<=1'b1;
+    always @(posedge clk) begin
+        if (~resetn) begin
+            pf_exc_reg <= 1'b0;
+            pf_ertn_reg <= 1'b0;
+        end 
+        else if (wb_exc) begin
+            pf_exc_reg <= 1'b1;
+        end 
+        else if (ertn_flush) begin
+            pf_ertn_reg <= 1'b1;
+        end 
+        else if (inst_sram_addr_ok && if_allowin && ~cancel)begin
+            pf_exc_reg <= 1'b0;
+            pf_ertn_reg <= 1'b0;
         end
     end
     //地址信息
     always @(posedge clk ) begin
-        if(~resetn||pf_ready_go&&if_allowin)begin
+        if (~resetn) begin
             br_target_reg <= 32'b0;
         end
-        else if (~br_stall & br_taken) begin
+        else if (br_taken && !br_stall) begin
             br_target_reg <= br_target;
-        end
+        end 
+        else if (inst_sram_addr_ok && ~cancel && if_allowin)begin
+            br_target_reg <= 32'b0;
+        end 
     end
     always @(posedge clk ) begin
-        if(~resetn||pf_ready_go&&if_allowin)begin
-            entaddr_reg <= 32'b0;
-            retaddr_reg <= 32'b0;
-        end
+        if (~resetn) begin
+            pf_entaddr_reg <= 32'b0;
+            pf_retaddr_reg <= 32'b0;
+        end 
         else if (wb_exc) begin
-            entaddr_reg <= exc_entaddr;
-        end
+            pf_entaddr_reg <= exc_entaddr;
+        end 
         else if (ertn_flush) begin
-            retaddr_reg <= exc_retaddr;
+            pf_retaddr_reg <= exc_retaddr;
+        end 
+        else if (inst_sram_addr_ok && if_allowin && ~cancel)begin
+            pf_entaddr_reg <= 32'b0;
+            pf_retaddr_reg <= 32'b0;
         end
     end
     //向指令存储器发送申请
-    assign inst_sram_req = pf_valid & ~br_stall & if_allowin;//add
-    assign inst_sram_addr = pf_nextpc;
-    assign inst_sram_size = 2'h2;
-    assign inst_sram_wstrb = 4'b0;
-    assign inst_sram_wdata = 32'b0;
-    assign inst_sram_wr    = 1'b0;//don't write
+    assign inst_sram_req = resetn && pf_valid && if_allowin && ~cancel;//add
+    assign inst_sram_addr = pf_nextpc   ;
+    assign inst_sram_size = 2'h2        ;
+    assign inst_sram_wstrb = 4'b0       ;
+    assign inst_sram_wdata = 32'b0      ;
+    assign inst_sram_wr    = 1'b0       ;//don't write
+    reg     cancel;//flush用于避免陷入时出现pc和指令不相同的情况
+    always @(posedge clk ) begin
+        if(~resetn)begin
+            cancel <= 1'b0;
+        end
+        else if(inst_sram_req && (ertn_flush||wb_exc||(br_stall&&inst_sram_addr_ok)))begin
+            cancel <= 1'b1;
+        end
+        else if(inst_sram_data_ok)begin
+            cancel <= 1'b0;
+        end
+    end
 //IF阶段，完成取指，传递给下个ID阶段
     //流水线控制信号
     reg         if_valid;
     wire        if_ready_go;
     wire        if_allowin;
     assign if_allowin = if_ready_go && id_allowin || ~if_valid;
-    assign if_ready_go = inst_sram_data_ok & if_valid | buffer_valid;//inst_cancel
-    assign if_id_valid = ~inst_cancel & if_valid & if_ready_go & ~(wb_exc | ertn_flush |(br_taken&~br_stall)) ;
+    assign if_ready_go = inst_sram_data_ok & if_valid | buffer_valid;//is_ertn_exc
+    assign if_id_valid = ~is_ertn_exc & if_valid & if_ready_go;
     always @(posedge clk ) begin
         if(~resetn)begin
             if_valid <= 1'b0;
@@ -139,10 +166,32 @@ module IF (
             if_valid <= pf_if_valid;
         end//例外
     end
+    //控制信号
+    reg             if_exc_reg;
+    reg             if_ertn_reg;
+    always @(posedge clk) begin
+        if (~resetn) begin
+            if_exc_reg <= 1'b0;
+            if_ertn_reg <= 1'b0;
+        end 
+        else if (wb_exc) begin
+            if_exc_reg <= 1'b1;
+        end 
+        else if (ertn_flush) begin
+            if_ertn_reg <= 1'b1;
+        end 
+        else if (if_allowin && pf_if_valid)begin
+            if_exc_reg <= 1'b0;
+            if_ertn_reg <= 1'b0;
+        end 
+    end
     //接preIF
     reg [31:0]  if_pc_reg;
     always @(posedge clk ) begin
-        if(pf_if_valid & if_allowin)begin
+        if(~resetn)begin
+            if_pc_reg<=32'b0;
+        end
+        else if(pf_if_valid & if_allowin)begin
             if_pc_reg <= pf_nextpc;
         end
     end
@@ -158,27 +207,16 @@ module IF (
     assign if_exc_type[`TYPE_INT]  = 1'b0;
     //取指
     reg         buffer_valid;
-    reg         inst_cancel;
+    wire        is_ertn_exc;
     reg [31:0]  buffer;
     wire [31:0] if_inst;
     assign  if_inst = buffer_valid ? buffer : inst_sram_rdata;
-    always @(posedge clk ) begin
-        if(~resetn)begin
-            inst_cancel <= 1'b0;
-        end
-        else if (((br_taken & ~br_stall) | wb_exc | ertn_flush) & 
-                    ~if_ready_go & ~if_allowin) begin
-            inst_cancel <= 1'b1;
-        end
-        else if (inst_sram_data_ok) begin
-            inst_cancel <= 1'b0;
-        end
-    end
+    assign is_ertn_exc = wb_exc | ertn_flush | if_ertn_reg | if_exc_reg;
     always @(posedge clk ) begin
         if(~resetn)begin
             buffer_valid <= 1'b0;
         end
-        else if (inst_sram_data_ok & ~buffer_valid & ~inst_cancel & ~id_allowin)begin
+        else if (inst_sram_data_ok & ~buffer_valid & ~is_ertn_exc & ~id_allowin)begin
             buffer_valid <= 1'b1;
         end
         else if (id_allowin | ertn_flush | wb_exc) begin
@@ -189,7 +227,7 @@ module IF (
         if(~resetn)begin
             buffer <= 32'b0;
         end
-        else if (inst_sram_data_ok & ~buffer_valid & ~inst_cancel & ~id_allowin)begin
+        else if (inst_sram_data_ok & ~buffer_valid & ~is_ertn_exc & ~id_allowin)begin
             buffer <= inst_sram_rdata;
         end
         else if (id_allowin | ertn_flush | wb_exc) begin
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/MEM.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/MEM.v
index 4c851fd..a2dec34 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/MEM.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/MEM.v
@@ -14,21 +14,30 @@ module MEM (
     //与数据存储器
     input   [ 31:0]                         data_sram_rdata,
     input                                   data_sram_data_ok,
-    //写信号
+    //写信�?
     output  [`MEM_WR_BUS_WDTH - 1:0]        mem_wr_bus,
     output                                  mem_exc,
     output  [`MEM_CSR_BLK_BUS_WDTH - 1:0]   mem_csr_blk_bus,
-    //中断和异常信号
+    //中断和异常信�?
     input                                   wb_exc,
     input                                   ertn_flush,
     output                                  mem_ertn        ,
     output                                  ldst_cancel 
 );
+//����
+wire mem_en_block;
+assign mem_en_block=is_load & mem_valid;
+
+
+
+
+
+
 //信号定义
     //控制信号
     reg                                     mem_valid;
     wire                                    mem_ready_go;
-    //pc和指令
+    //pc和指�?
     wire    [ 31:0]                         mem_pc;
     wire    [ 31:0]                         mem_inst;
     //bus
@@ -47,12 +56,12 @@ module MEM (
     wire    [31:0]                          mem_csr_wdata;
     wire    [31:0]                          mem_csr_rdata;
     wire    [31:0]                          mem_csr_wmask;
-    //中断和异常标志
+    //中断和异常标�?
     wire    [`NUM_TYPES - 1:0]               exe_exc_type;
     wire    [`NUM_TYPES - 1:0]               mem_exc_type;
     wire                                    ls_cancel;
     wire                                    mem_we;
-//控制信号的赋值
+//控制信号的赋�?
     assign  mem_ready_go = (is_load | mem_we) ?  (|mem_exc_type) | ls_cancel | data_sram_data_ok : 1'b1;
     assign  mem_wb_valid = mem_ready_go & mem_valid &  ~is_ertn_exc;
     assign  mem_allowin = mem_ready_go & wb_allowin | ~mem_valid;
@@ -65,7 +74,10 @@ module MEM (
     end
 //主bus连接
     always @(posedge clk ) begin
-        if (exe_mem_valid & mem_allowin) begin
+        if(~resetn)begin
+            exe_mem_bus_vld <= `EXE_MEM_BUS_WDTH'b0;
+        end
+        else if (exe_mem_valid & mem_allowin) begin
             exe_mem_bus_vld <= exe_mem_bus;
         end
     end
@@ -110,11 +122,11 @@ module MEM (
                                 res_from_mem            ?   mem_ld_result   : 
                                                             exe_to_mem_result      ;
     assign mem_exc = (|mem_exc_type) & mem_valid;
-//阻塞和前递
+//阻塞和前�?
     assign  mem_en_bypass = mem_valid & mem_gr_we;
-    assign  mem_wr_bus = {mem_en_bypass, mem_dest, mem_final_result};
+    assign  mem_wr_bus = {mem_en_bypass,mem_en_block, mem_dest, mem_final_result};
     assign  mem_csr_blk_bus= {mem_csr_we & mem_valid, mem_ertn, mem_csr_waddr};
-//中断和异常标志
+//中断和异常标�?
     assign mem_exc_type = exe_exc_type;
     assign mem_ertn = mem_valid & mem_inst_ertn;
 //add
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/WB.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/WB.v
index 51a092f..0126168 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/WB.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/WB.v
@@ -59,7 +59,10 @@ module WB (
     end
 //主bus连接
     always @(posedge clk ) begin
-        if (mem_wb_valid & wb_allowin) begin
+        if(~resetn)begin
+            mem_wb_bus_vld <= `MEM_WB_BUS_WDTH'b0;
+        end
+        else if (mem_wb_valid & wb_allowin) begin
             mem_wb_bus_vld <= mem_wb_bus;
         end
     end
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/bridge.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/bridge.v
new file mode 100644
index 0000000..e0110fb
--- /dev/null
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/bridge.v
@@ -0,0 +1,454 @@
+`define RREQ_WAIT 5'b00001
+`define RREQ_INST 5'b00010
+`define RREQ_TRAW 5'b00100
+`define RREQ_DATA 5'b01000
+`define RREQ_END  5'b10000
+`define RVAL_WAIT 3'b001
+`define RVAL_DATA 3'b010
+`define RVAL_END  3'b100
+`define WREQ_WAIT 4'b0001
+`define WREQ_TRAW 4'b0010
+`define WREQ_DATA 4'b0100
+`define WREQ_END  4'b1000
+`define WRSP_WAIT 3'b001
+`define WRSP_BEGN 3'b010
+`define WRSP_END  3'b100
+module AXI_bridge (
+    //时钟与复位信�?
+    input               aclk,
+    input               aresetn,
+    //读请求�?�道，以ar�?�?
+    //master->slave
+    output  [ 3:0]      arid,
+    output  [31:0]      araddr,
+    output  [ 7:0]      arlen,
+    output  [ 2:0]      arsize,
+    output  [ 1:0]      arburst,
+    output  [ 1:0]      arlock,
+    output  [ 3:0]      arcache,
+    output  [ 2:0]      arprot,
+    output              arvalid,
+    input               arready,
+    //读响应�?�道，以r�?�?
+    input   [ 3:0]      rid,
+    input   [31:0]      rdata,
+    input   [ 1:0]      rresp,
+    input               rlast,
+    input               rvalid,
+    output              rready,
+    //写请求�?�道，以aw�?�?
+    output  [ 3:0]      awid,
+    output  [31:0]      awaddr,
+    output  [ 7:0]      awlen,
+    output  [ 2:0]      awsize,
+    output  [ 1:0]      awburst,
+    output  [ 1:0]      awlock,
+    output  [ 3:0]      awcache,
+    output  [ 2:0]      awprot,
+    output              awvalid,
+    input               awready,
+    //写数据�?�道，以w�?�?
+    output  [ 3:0]      wid,
+    output  [31:0]      wdata,
+    output  [ 3:0]      wstrb,
+    output              wlast,
+    output              wvalid,
+    input               wready,
+    //写响应�?�道，以b�?�?
+    input   [ 3:0]      bid,
+    input   [ 1:0]      bresp,
+    input               bvalid,
+    output              bready,
+    //指令存储器相�?
+    //in
+    input               inst_sram_req,
+    input               inst_sram_wr,
+    input   [ 3:0]      inst_sram_wstrb,
+    input   [ 1:0]      inst_sram_size,
+    input   [31:0]      inst_sram_addr,
+    input   [31:0]      inst_sram_wdata,
+    //out
+    output  [31:0]      inst_sram_rdata,
+    output              inst_sram_addr_ok,
+    output              inst_sram_data_ok,
+    //数据存储器相�?
+    //in
+    input               data_sram_req,
+    input               data_sram_wr,
+    input   [ 3:0]      data_sram_wstrb,
+    input   [ 1:0]      data_sram_size,
+    input   [31:0]      data_sram_addr,
+    input   [31:0]      data_sram_wdata,
+    //out       
+    output              data_sram_addr_ok,
+    output              data_sram_data_ok,
+    output  [31:0]      data_sram_rdata
+);
+//读请�?
+    reg     [ 4:0]      rreq_state;
+    reg     [ 4:0]      rreq_next_state;
+    always @(posedge aclk ) begin
+        if(~aresetn)begin
+            rreq_state <= `RREQ_WAIT;
+        end
+        else begin
+            rreq_state <= rreq_next_state;
+        end
+    end
+    always @(*) begin
+        case (rreq_state)
+            `RREQ_WAIT:
+                if(data_sram_req && !data_sram_wr) //读数据请�?
+                    rreq_next_state = `RREQ_TRAW;
+                else if(inst_sram_req)
+                    rreq_next_state = `RREQ_INST;
+                else
+                    rreq_next_state = `RREQ_WAIT;
+            `RREQ_DATA:
+                if(arvalid && arready)
+                    rreq_next_state = `RREQ_END;
+                else
+                    rreq_next_state = `RREQ_DATA;
+            `RREQ_INST://可以合并
+                if(arvalid && arready)
+                    rreq_next_state = `RREQ_END;
+                else
+                    rreq_next_state = `RREQ_INST;
+            `RREQ_TRAW:
+                if(bready && raw_blk)
+                    rreq_next_state = `RREQ_TRAW;
+                else
+                    rreq_next_state = `RREQ_DATA;
+            `RREQ_END:
+                rreq_next_state = `RREQ_WAIT;
+            default: 
+                rreq_next_state = `RREQ_WAIT;
+        endcase
+    end
+//读数�?
+    reg     [2:0]   rval_state;
+    reg     [2:0]   rval_next_state;
+    always @(posedge aclk ) begin
+        if(~aresetn)begin
+            rval_state <= `RVAL_WAIT;
+        end
+        else begin
+            rval_state <= rval_next_state;
+        end
+    end
+    always @(*) begin
+        case (rval_state)
+            `RVAL_WAIT: 
+                if((|rinst_cnt)||(|rdata_cnt)||(arready&&arvalid))
+                    rval_next_state = `RVAL_DATA;
+                else 
+                    rval_next_state = `RVAL_WAIT;
+            `RVAL_DATA:
+                if(rvalid && rready)
+                    rval_next_state = `RVAL_END;
+                else 
+                    rval_next_state = `RVAL_DATA;
+            `RVAL_END:
+                if(rvalid && rready)
+                    rval_next_state = `RVAL_END;
+                else if((|rinst_cnt)||(|rdata_cnt))
+                    rval_next_state = `RVAL_DATA;
+                else
+                    rval_next_state = `RVAL_WAIT;
+            default: 
+                    rval_next_state = `RVAL_WAIT;
+        endcase
+    end
+//写请�?
+    reg     [3:0]   wreq_state;
+    reg     [3:0]   wreq_next_state;
+    always @(posedge aclk ) begin
+        if (~aresetn) begin
+            wreq_state <= `WREQ_WAIT;
+        end
+        else begin
+            wreq_state <= wreq_next_state;
+        end
+    end
+    always @(*) begin
+        case (wreq_state)
+            `WREQ_WAIT: 
+                if(data_sram_req && data_sram_wr)
+                    wreq_next_state = `WREQ_TRAW;
+                else
+                    wreq_next_state = `WREQ_WAIT;
+            `WREQ_TRAW:
+                if(rready && raw_blk)
+                    wreq_next_state = `WREQ_TRAW;
+                else 
+                    wreq_next_state = `WREQ_DATA;
+            `WREQ_DATA:
+                if(wvalid && wready)
+                    wreq_next_state = `WREQ_END;
+                else
+                    wreq_next_state = `WREQ_DATA;
+            `WREQ_END:
+                wreq_next_state = `WREQ_WAIT;
+            default: 
+                wreq_next_state = `WREQ_WAIT;
+        endcase
+    end
+//写响�?
+    reg     [2:0]   wrsp_state;
+    reg     [2:0]   wrsp_next_state;
+    always @(posedge aclk ) begin
+        if(~aresetn)begin
+            wrsp_state <= `WRSP_WAIT;
+        end
+        else begin
+            wrsp_state <= wrsp_next_state;
+        end
+    end
+    always @(*) begin
+        case (wrsp_state)
+            `WRSP_WAIT:
+                if(wvalid && wready)
+                    wrsp_next_state = `WRSP_BEGN;
+                else
+                    wrsp_next_state = `WRSP_WAIT;
+            `WRSP_BEGN:
+                if(bvalid && bready) 
+                    wrsp_next_state = `WRSP_END;
+                else 
+                    wrsp_next_state = `WRSP_BEGN;
+            `WRSP_END:
+                if(bvalid && bready)
+                    wrsp_next_state = `WRSP_END;
+                else if((wvalid && wready) || (wtask_cnt != 2'b0))//ontest
+                    wrsp_next_state = `WRSP_BEGN;
+                else 
+                    wrsp_next_state = `WRSP_WAIT;
+            default: 
+                wrsp_next_state = `WRSP_WAIT;
+        endcase
+    end
+//ports
+    //ar
+    reg     [ 3:0]      arid_r;
+    reg     [ 2:0]      arsize_r;
+    reg     [31:0]      araddr_r;
+    reg                 arvalid_r;
+    assign arid = arid_r;
+    assign araddr = araddr_r;
+    assign arlen = 8'b0;
+    assign arsize = arsize_r;
+    assign arburst = 2'b1;
+    assign arlock = 2'b0;
+    assign arcache = 4'b0;
+    assign arprot = 3'b0;
+    assign arvalid = arvalid_r;
+    always @(posedge aclk ) begin
+        if(~aresetn)begin
+            arid_r <= 4'b0;
+            arsize_r <= 3'b0;
+            araddr_r <= 32'b0;
+        end
+        else if(rreq_state[3]|rreq_next_state[3])begin
+            arid_r <= 4'b1;
+            arsize_r <= {1'b0,data_sram_size};
+            araddr_r <= data_sram_addr;
+        end
+        else if(rreq_next_state[1]|rreq_state[1])begin
+            arid_r <= 4'b0;
+            arsize_r <= {1'b0,inst_sram_size};
+            araddr_r <= inst_sram_addr;
+        end
+        else begin
+            arid_r <= 4'b0;
+            arsize_r <= 3'b0;
+            araddr_r <= 32'b0;
+        end
+    end
+    always @(posedge aclk) begin
+        if(~aresetn|arready) begin
+            arvalid_r <= 1'b0;
+        end 
+        else if(rreq_state[1]|rreq_state[3]) begin
+            arvalid_r <= 1'b1;
+        end 
+        else begin
+            arvalid_r <= arvalid_r;
+        end
+    end
+    //r
+    assign rready=rinst_cnt!=2'b0 || rdata_cnt!=2'b0;
+    reg [3:0]   rid_r;
+    always @(posedge aclk) begin
+        if(~aresetn|rval_next_state[0]) begin
+            rid_r <= 4'b0;
+        end 
+        else if(rvalid) begin
+            rid_r <= rid;
+        end
+    end
+    //aw
+    reg     [31:0]  awaddr_r;
+    reg     [ 2:0]  awsize_r;
+    reg             awvalid_r;
+    reg             awready_r;
+    assign awid    = 4'b1;
+    assign awaddr  = awaddr_r;
+    assign awlen   = 8'b0;
+    assign awsize  = awsize_r;
+    assign awburst = 2'b01;
+    assign awlock  = 2'b0;
+    assign awcache = 4'b0;
+    assign awprot  = 3'b0;
+    assign awvalid = awvalid_r;
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            awaddr_r <= 32'b0;
+            awsize_r <= 3'b0;
+        end 
+        else if(wreq_state[2])begin
+            awaddr_r <= data_sram_addr;
+            awsize_r <= {1'b0,data_sram_size};
+        end 
+        else begin
+            awaddr_r <= 32'b0;
+            awsize_r <= 3'b0;
+        end
+    end
+    always @(posedge aclk) begin
+        if(~aresetn || awready || awready_r) begin
+            awvalid_r <= 1'b0;
+        end
+        else if(wreq_state[2]) begin
+            awvalid_r <= 1'b1;
+        end
+    end
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            awready_r <= 1'b0;
+        end
+        else if(awvalid && awready) begin
+            awready_r <= 1'b1;
+        end 
+        else if(wreq_next_state[3]) begin
+            awready_r <= 1'b0;
+        end
+    end
+    //w
+    reg     [31:0]  wdata_r;
+    reg     [ 3:0]  wstrb_r;
+    reg             wvalid_r;
+    assign wid     = 4'b1;
+    assign wdata   = wdata_r;
+    assign wstrb   = wstrb_r;
+    assign wlast   = 1'b1;
+    assign wvalid  = wvalid_r;
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            wdata_r <= 32'b0;
+            wstrb_r <= 4'b0;
+        end 
+        else if(wreq_state[2]) begin
+            wdata_r <= data_sram_wdata;
+            wstrb_r <= data_sram_wstrb;
+        end
+    end
+    always @(posedge aclk) begin
+        if(~aresetn || wready) begin
+            wvalid_r <= 1'b0;
+        end 
+        else if(wreq_state[2]) begin
+            wvalid_r <= 1'b1;
+        end 
+        else begin
+            wvalid_r <= 1'b0;
+        end
+    end
+    //b
+    reg     bready_r;
+    assign bready  = bready_r;
+    always @(posedge aclk) begin
+        if(~aresetn || bvalid) begin
+            bready_r <= 1'b0;
+        end 
+        else if(wrsp_next_state[1]) begin
+            bready_r <= 1'b1;
+        end 
+        else begin
+            bready_r <= 1'b0;
+        end
+    end    
+//任务计数�?
+    reg [1:0]   rinst_cnt;
+    reg [1:0]   rdata_cnt;
+    reg [1:0]   wtask_cnt;
+    always @(posedge aclk ) begin
+        if(~aresetn)
+            rinst_cnt<=2'b0;
+        else if ((arready&&arvalid)&&(rready&&rvalid))begin
+            if(arid==4'b0&&rid==4'b1)
+                rinst_cnt<=rinst_cnt+2'b1;
+            else if(arid==4'b1&&rid==4'b0)
+                rinst_cnt<=rinst_cnt-2'b1;
+        end
+        else if(rready&&rvalid)
+            rinst_cnt<=rinst_cnt-2'b1;
+        else if(arready&&arvalid)
+            rinst_cnt<=rinst_cnt+2'b1;
+    end
+    always @(posedge aclk ) begin
+        if(~aresetn)
+            rdata_cnt<=2'b0;
+        else if ((arready&&arvalid)&&(rready&&rvalid))begin
+            if(arid==4'b0&&rid==4'b1)
+                rdata_cnt<=rdata_cnt-2'b1;
+            else if(arid==4'b1&&rid==4'b0)
+                rdata_cnt<=rdata_cnt+2'b1;
+        end
+        else if(rready&&rvalid)
+            rdata_cnt<=rdata_cnt-2'b1;
+        else if(arready&&arvalid)
+            rdata_cnt<=rdata_cnt+2'b1;
+    end
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            wtask_cnt <= 2'b0;
+        end 
+        else if((bvalid&&bready)&&(wvalid&&wready)) begin
+            wtask_cnt <= wtask_cnt;
+        end 
+        else if(wvalid&&wready) begin
+            wtask_cnt<=wtask_cnt+2'b1;
+        end 
+        else if(bvalid&&bready) begin
+            wtask_cnt<=wtask_cnt-2'b1;
+        end
+    end
+//写后读相关检�?
+    wire    raw_blk;
+    assign raw_blk = arvalid_r && awvalid_r && (awaddr_r == araddr_r);
+//ok信号与数�?
+    reg     [31:0]  inst_buffer;
+    reg     [31:0]  data_buffer;
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            inst_buffer <= 32'b0;
+        end 
+        else if(rvalid && rready && ~rid[0]) begin
+            inst_buffer <= rdata;
+        end
+    end
+    always @(posedge aclk) begin
+        if(~aresetn) begin
+            data_buffer <= 32'b0;
+        end 
+        else if(rvalid && rready && rid[0]) begin
+            data_buffer <= rdata;
+        end
+    end
+    assign inst_sram_rdata = inst_buffer;
+    assign data_sram_rdata = data_buffer;
+    assign inst_sram_addr_ok = rreq_state[4]&~arid[0];
+    assign inst_sram_data_ok = rval_state[2]&~rid_r[0];
+    assign data_sram_addr_ok = rreq_state[4]&arid[0]|wreq_state[3];
+    assign data_sram_data_ok = rval_state[2]&rid_r[0]|wrsp_state[2];
+endmodule
\ No newline at end of file
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/csr.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/csr.v
index b6839f5..2937674 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/csr.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/csr.v
@@ -51,21 +51,21 @@ module csr(
         else if (csr_we && csr_waddr==`CSR_CRMD)
             csr_crmd_ie <= csr_wmask[`CSR_CRMD_PIE]&csr_wdata[`CSR_CRMD_PIE]| ~csr_wmask[`CSR_CRMD_PIE]&csr_crmd_ie;
     end
-    //CRMD-DA
-    always @(posedge clk) begin
-        if (ertn_flush&&csr_estat_ecode==6'h3f)
-            csr_crmd_da <= 1'b0;
-        else 
-            csr_crmd_da <= 1'b1;
-    end
-    //CRMD-PG
-    always @(posedge clk) begin
-        if (ertn_flush&&csr_estat_ecode==6'h3f)
-            csr_crmd_pg <= 1'b1;
-        else 
-            csr_crmd_pg <= 1'b0;
-    end
-    assign  csr_crmd_rdata = {27'b0, csr_crmd_pg, csr_crmd_da, csr_crmd_ie, csr_crmd_plv};
+    // //CRMD-DA
+    // always @(posedge clk) begin
+    //     if (ertn_flush&&csr_estat_ecode==6'h3f)
+    //         csr_crmd_da <= 1'b0;
+    //     else 
+    //         csr_crmd_da <= 1'b1;
+    // end
+    // //CRMD-PG
+    // always @(posedge clk) begin
+    //     if (ertn_flush&&csr_estat_ecode==6'h3f)
+    //         csr_crmd_pg <= 1'b1;
+    //     else 
+    //         csr_crmd_pg <= 1'b0;
+    // end
+    assign  csr_crmd_rdata = {28'b0, 1'b1, csr_crmd_ie, csr_crmd_plv};
 
 
     //PRMD
@@ -74,7 +74,11 @@ module csr(
     wire    [31:0]  csr_prmd_rdata;
     //PRMD-PPLV,PIE
     always @(posedge clk) begin
-        if (wb_exc) begin
+        if(~resetn)begin
+            csr_prmd_pie<=1'b0;
+            csr_prmd_pplv<=2'b0;
+        end
+        else if (wb_exc) begin
             csr_prmd_pplv <= csr_crmd_plv;
             csr_prmd_pie <= csr_crmd_ie;
         end
@@ -113,7 +117,11 @@ module csr(
             | ~csr_wmask[`CSR_ESTAT_IS10]&csr_estat_is[1:0];
         csr_estat_is[9:2] <= 8'b0;//hwint=0
         csr_estat_is[10] <= 1'b0;//eternal 0
-        if (csr_tcfg_en & timer_cnt == 32'b0) begin
+        csr_estat_is[12] <= 1'b0;//ipiint=0
+        if(~resetn)begin
+            csr_estat_is[11] <= 1'b0;
+        end
+        else if (csr_tcfg_en & timer_cnt == 32'b0) begin
             csr_estat_is[11] <= 1'b1;
         end
         else if (csr_we && csr_waddr == `CSR_TICLR    &&
@@ -121,10 +129,13 @@ module csr(
                                csr_wdata[`CSR_TICLR_CLR]) begin
             csr_estat_is[11] <= 1'b0;//软件通过向CLR写1来将estatis第十一位清零
         end
-        csr_estat_is[12] <= 1'b0;//ipiint=0
     end
     always @(posedge clk) begin
-        if (wb_exc) begin
+        if(~resetn)begin
+            csr_estat_ecode <= 6'b0;
+            csr_estat_esubcode <= 9'b0;
+        end
+        else if (wb_exc) begin
             csr_estat_ecode <= wb_ecode;
             csr_estat_esubcode <= wb_esubcode;
         end
@@ -138,7 +149,10 @@ module csr(
     wire    [31:0]  csr_era_rdata;
     //ERA-PC
     always @(posedge clk) begin
-        if (wb_exc)
+        if(~resetn)begin
+            csr_era_pc <= 32'b0;
+        end
+        else if (wb_exc)
             csr_era_pc <= wb_pc;
         else if (csr_we && csr_waddr==`CSR_ERA)
             csr_era_pc <= csr_wmask[`CSR_ERA_PC]&csr_wdata[`CSR_ERA_PC] | ~csr_wmask[`CSR_ERA_PC]&csr_era_pc;
@@ -150,7 +164,10 @@ module csr(
     wire    [31:0]  csr_eentry_rdata;
     //EENTRY-VA
     always @(posedge clk) begin
-        if (csr_we && csr_waddr==`CSR_EENTRY)
+        if(~resetn)begin
+            csr_eentry_va <= 26'b0;
+        end
+        else if (csr_we && csr_waddr==`CSR_EENTRY)
             csr_eentry_va <= csr_wmask[`CSR_EENTRY_VA]&csr_wdata[`CSR_EENTRY_VA] | ~csr_wmask[`CSR_EENTRY_VA]&csr_eentry_va;
     end
     assign  csr_eentry_rdata = {
@@ -168,14 +185,22 @@ module csr(
     wire    [31:0]  csr_save3_rdata;
     //SAVE 0~3
     always @(posedge clk) begin
-        if (csr_we && csr_waddr==`CSR_SAVE0)
-            csr_save0_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save0_data;
-        if (csr_we && csr_waddr==`CSR_SAVE1)
-            csr_save1_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save1_data;
-        if (csr_we && csr_waddr==`CSR_SAVE2)
-            csr_save2_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save2_data;
-        if (csr_we && csr_waddr==`CSR_SAVE3)
-            csr_save3_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save3_data;
+        if(~resetn)begin
+            csr_save0_data <= 32'b0;
+            csr_save1_data <= 32'b0;
+            csr_save2_data <= 32'b0;
+            csr_save3_data <= 32'b0;
+        end
+        else begin
+            if (csr_we && csr_waddr==`CSR_SAVE0)
+                csr_save0_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save0_data;
+            if (csr_we && csr_waddr==`CSR_SAVE1)
+                csr_save1_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save1_data;
+            if (csr_we && csr_waddr==`CSR_SAVE2)
+                csr_save2_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save2_data;
+            if (csr_we && csr_waddr==`CSR_SAVE3)
+                csr_save3_data <= csr_wmask[`CSR_SAVE_DATA]&csr_wdata[`CSR_SAVE_DATA] | ~csr_wmask[`CSR_SAVE_DATA]&csr_save3_data; 
+        end
     end
     assign {
         csr_save0_rdata, csr_save1_rdata, csr_save2_rdata, csr_save3_rdata
@@ -192,6 +217,8 @@ module csr(
     always @ (posedge clk) begin
         if (~resetn) begin
             csr_tcfg_en <= 1'b0;
+            csr_tcfg_periodic <= 1'b0;
+            csr_tcfg_initdata <= 30'b0;
         end else if (csr_we && csr_waddr == `CSR_TCFG) begin
             csr_tcfg_en      <= csr_wmask[`CSR_TCFG_EN] & csr_wdata[`CSR_TCFG_EN] |
                                ~csr_wmask[`CSR_TCFG_EN] & csr_tcfg_en;
@@ -248,7 +275,10 @@ module csr(
     wire [31:0] csr_badv_rdata;
     assign wb_exc_addr_err = wb_ecode==`EXC_ECODE_ADE || wb_ecode==`EXC_ECODE_ALE;
     always @(posedge clk) begin
-        if (wb_exc && wb_exc_addr_err)
+        if(~resetn)begin
+            csr_badv_vaddr <= 32'b0;
+        end
+        else if (wb_exc && wb_exc_addr_err)
             csr_badv_vaddr <= (wb_ecode==`EXC_ECODE_ADE && 
                                wb_esubcode==`EXC_ESUBCODE_ADEF) ? wb_pc : wb_badvaddr;
     end
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu.h b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu.h
index bcbb106..87875a7 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu.h
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu.h
@@ -7,7 +7,7 @@
     `define EXE_MEM_BUS_WDTH 191
     `define MEM_WB_BUS_WDTH 188
     `define EXE_WR_BUS_WDTH 39
-    `define MEM_WR_BUS_WDTH 38
+    `define MEM_WR_BUS_WDTH 39
     `define EXE_CSR_BLK_BUS_WDTH 16
     `define MEM_CSR_BLK_BUS_WDTH 16
     `define WB_CSR_BLK_BUS_WDTH 16
diff --git a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu_top.v b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu_top.v
index 06e78d0..2255241 100644
--- a/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu_top.v
+++ b/exp15/cdp_ede_local-Lab07_exp15/mycpu_env/myCPU/mycpu_top.v
@@ -1,33 +1,66 @@
 `include "mycpu.h"
 module mycpu_top(
-    input  wire        clk,
-    input  wire        resetn,
-    // inst sram interface
-    output        inst_sram_req,
-    output        inst_sram_wr,
-    output [ 1:0] inst_sram_size,
-    output [31:0] inst_sram_addr,
-    output [ 3:0] inst_sram_wstrb,
-    output [31:0] inst_sram_wdata,
-    input         inst_sram_addr_ok,
-    input         inst_sram_data_ok,
-    input  [31:0] inst_sram_rdata,
-    // data sram interface
-    output        data_sram_req,
-    output        data_sram_wr,
-    output [ 1:0] data_sram_size,
-    output [31:0] data_sram_addr,
-    output [ 3:0] data_sram_wstrb,
-    output [31:0] data_sram_wdata,
-    input         data_sram_addr_ok,
-    input         data_sram_data_ok,
-    input  [31:0] data_sram_rdata,
+    input  wire        aclk,
+    input  wire        aresetn,
+    // read requeset
+    // master->slave
+    output [ 3:0]   arid,
+    output [31:0]   araddr,
+    output [ 7:0]   arlen,
+    output [ 2:0]   arsize,
+    output [ 1:0]   arburst,
+    output [ 1:0]   arlock,
+    output [ 3:0]   arcache,
+    output [ 2:0]   arprot,
+    output          arvalid,
+    // slave->master
+    input           arready,
+    // read response
+    // slave->master
+    input  [ 3:0]   rid,
+    input  [31:0]   rdata,
+    input  [ 1:0]   rresp,
+    input           rlast,
+    input           rvalid,
+    // master->slave
+    output          rready,
+    // write request
+    // master->slave
+    output [ 3:0]   awid,
+    output [31:0]   awaddr,
+    output [ 7:0]   awlen,
+    output [ 2:0]   awsize,
+    output [ 1:0]   awburst,
+    output [ 1:0]   awlock,
+    output [ 3:0]   awcache,
+    output [ 2:0]   awprot,
+    output          awvalid,
+    // slave->master
+    input           awready,
+    // write data
+    // master->slave
+    output  [ 3:0]  wid,
+    output  [31:0]  wdata,
+    output  [ 3:0]  wstrb,
+    output          wlast,
+    output          wvalid,
+    // slave->master
+    input           wready,
+    // write response
+    // slave->master
+    input  [ 3:0]   bid,
+    input  [ 1:0]   bresp,
+    input           bvalid,
+    // master->slave
+    output          bready,
+
     // trace debug interface
     output wire [31:0] debug_wb_pc,
     output wire [ 3:0] debug_wb_rf_we,
     output wire [ 4:0] debug_wb_rf_wnum,
     output wire [31:0] debug_wb_rf_wdata
 );
+
     //信号定义
     wire                                    id_allowin;
     wire                                    if_id_valid;
@@ -71,11 +104,95 @@ module mycpu_top(
     wire    [31:0]                          wb_badvaddr;
     wire                                    ldst_cancel;
 
-   //模块调用
+    // inst sram interface
+    wire            inst_sram_req;
+    wire            inst_sram_wr;
+    wire  [ 1:0]    inst_sram_size;
+    wire  [31:0]    inst_sram_addr;
+    wire  [ 3:0]    inst_sram_wstrb;
+    wire  [31:0]    inst_sram_wdata;
+    wire            inst_sram_addr_ok;
+    wire            inst_sram_data_ok;
+    wire [31:0]     inst_sram_rdata;
+    // data sram interface
+    wire            data_sram_req;
+    wire            data_sram_wr;
+    wire  [ 1:0]    data_sram_size;
+    wire  [31:0]    data_sram_addr;
+    wire  [ 3:0]    data_sram_wstrb;
+    wire  [31:0]    data_sram_wdata;
+    wire            data_sram_addr_ok;
+    wire            data_sram_data_ok;
+    wire [31:0]     data_sram_rdata;
+
+    //模块调用
+    AXI_bridge my_AXI_bridge(
+        .aclk                (aclk       ),
+        .aresetn             (aresetn    ),   //low active
+
+        .arid               (arid      ),
+        .araddr             (araddr    ),
+        .arlen              (arlen     ),
+        .arsize             (arsize    ),
+        .arburst            (arburst   ),
+        .arlock             (arlock    ),
+        .arcache            (arcache   ),
+        .arprot             (arprot    ),
+        .arvalid            (arvalid   ),
+        .arready            (arready   ),
+                    
+        .rid                (rid       ),
+        .rdata              (rdata     ),
+        .rresp              (rresp     ),
+        .rlast              (rlast     ),
+        .rvalid             (rvalid    ),
+        .rready             (rready    ),
+                
+        .awid               (awid      ),
+        .awaddr             (awaddr    ),
+        .awlen              (awlen     ),
+        .awsize             (awsize    ),
+        .awburst            (awburst   ),
+        .awlock             (awlock    ),
+        .awcache            (awcache   ),
+        .awprot             (awprot    ),
+        .awvalid            (awvalid   ),
+        .awready            (awready   ),
+        
+        .wid                (wid       ),
+        .wdata              (wdata     ),
+        .wstrb              (wstrb     ),
+        .wlast              (wlast     ),
+        .wvalid             (wvalid    ),
+        .wready             (wready    ),
+        
+        .bid                (bid       ),
+        .bresp              (bresp     ),
+        .bvalid             (bvalid    ),
+        .bready             (bready    ),
+        .inst_sram_req      (inst_sram_req  ),
+        .inst_sram_wr       (inst_sram_wr   ),
+        .inst_sram_size     (inst_sram_size ),
+        .inst_sram_wstrb    (inst_sram_wstrb),
+        .inst_sram_addr     (inst_sram_addr ),
+        .inst_sram_wdata    (inst_sram_wdata),
+        .inst_sram_addr_ok  (inst_sram_addr_ok),
+        .inst_sram_data_ok  (inst_sram_data_ok),
+        .inst_sram_rdata    (inst_sram_rdata),
+        .data_sram_req      (data_sram_req    ),
+        .data_sram_wr       (data_sram_wr     ),
+        .data_sram_size     (data_sram_size   ),
+        .data_sram_addr     (data_sram_addr   ),
+        .data_sram_wstrb    (data_sram_wstrb  ),
+        .data_sram_wdata    (data_sram_wdata  ),
+        .data_sram_addr_ok  (data_sram_addr_ok),
+        .data_sram_data_ok  (data_sram_data_ok),
+        .data_sram_rdata    (data_sram_rdata  )
+    );
 
     IF my_IF (
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .id_allowin         (id_allowin),
         .if_id_valid        (if_id_valid),
         .if_id_bus          (if_id_bus),
@@ -95,8 +212,8 @@ module mycpu_top(
         .exc_retaddr        (exc_retaddr)
     );
     ID my_ID (
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .if_id_valid        (if_id_valid),
         .id_allowin         (id_allowin),
         .if_id_bus          (if_id_bus),
@@ -116,32 +233,32 @@ module mycpu_top(
         .csr_has_int        (csr_has_int)
     );
     EXE my_EXE (
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .exe_allowin        (exe_allowin),
         .id_exe_valid       (id_exe_valid),
         .id_exe_bus         (id_exe_bus),
         .exe_mem_valid      (exe_mem_valid),
         .mem_allowin        (mem_allowin),
         .exe_mem_bus        (exe_mem_bus),
-         .data_sram_req    (data_sram_req    ),
-        .data_sram_wr     (data_sram_wr     ),
-        .data_sram_size   (data_sram_size   ),
-        .data_sram_addr   (data_sram_addr   ),
-        .data_sram_wstrb  (data_sram_wstrb  ),
-        .data_sram_wdata  (data_sram_wdata  ),
-        .data_sram_addr_ok(data_sram_addr_ok),
+        .data_sram_req      (data_sram_req    ),
+        .data_sram_wr       (data_sram_wr     ),
+        .data_sram_size     (data_sram_size   ),
+        .data_sram_addr     (data_sram_addr   ),
+        .data_sram_wstrb    (data_sram_wstrb  ),
+        .data_sram_wdata    (data_sram_wdata  ),
+        .data_sram_addr_ok  (data_sram_addr_ok),
         .exe_wr_bus         (exe_wr_bus),
         .exe_csr_blk_bus    (exe_csr_blk_bus),
         .wb_exc             (wb_exc),
-        .ertn_flush            (ertn_flush),
+        .ertn_flush         (ertn_flush),
         .mem_ertn           (mem_ertn),
-        .mem_exc  (mem_exc),
-        .ldst_cancel (ldst_cancel)
+        .mem_exc            (mem_exc),
+        .ldst_cancel        (ldst_cancel)
     );
     MEM my_MEM (
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .mem_allowin        (mem_allowin),
         .exe_mem_valid      (exe_mem_valid),
         .exe_mem_bus        (exe_mem_bus),
@@ -149,18 +266,18 @@ module mycpu_top(
         .wb_allowin         (wb_allowin),
         .mem_wb_bus         (mem_wb_bus),
         .data_sram_rdata    (data_sram_rdata),
-        .data_sram_data_ok(data_sram_data_ok),
+        .data_sram_data_ok  (data_sram_data_ok),
         .mem_wr_bus         (mem_wr_bus),
         .mem_csr_blk_bus    (mem_csr_blk_bus),
         .wb_exc             (wb_exc),
         .mem_ertn           (mem_ertn),
-        .ertn_flush            (ertn_flush),
-        .mem_exc  (mem_exc),
-        .ldst_cancel (ldst_cancel)
+        .ertn_flush         (ertn_flush),
+        .mem_exc            (mem_exc),
+        .ldst_cancel        (ldst_cancel)
     );
     WB my_WB (
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .wb_allowin         (wb_allowin),
         .mem_wb_valid       (mem_wb_valid),
         .mem_wb_bus         (mem_wb_bus),
@@ -182,8 +299,8 @@ module mycpu_top(
         .wb_badvaddr        (wb_badvaddr)    
     );
     csr my_csr(
-        .clk                (clk),
-        .resetn             (resetn),
+        .clk                (aclk),
+        .resetn             (aresetn),
         .csr_we             (csr_we),
         .csr_waddr          (csr_waddr),
         .csr_wmask          (csr_wmask),
-- 
2.37.3.windows.1

